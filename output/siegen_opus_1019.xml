<mets:mets xmlns:mets="http://www.loc.gov/METS/" xmlns:mods="http://www.loc.gov/mods/v3"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <mets:dmdSec ID="DMD_siegen_opus_1019">
        <mets:mdWrap MIMETYPE="text/xml" MDTYPE="MODS">
            <mets:xmlData>
                <mods xmlns="http://www.loc.gov/mods/v3" version="3.7"
                    xmlns:vl="http://visuallibrary.net/vl">
                    <titleInfo lang="eng">
                        <title>Analysis of grammar-based tree compression</title>
                    </titleInfo>
                    <titleInfo lang="ger">
                        <title>Analyse grammatik-basierter Baumkompression</title>
                    </titleInfo>
                    <name type="personal">
                        <displayForm>Nöth, Eric</displayForm>
                        <namePart type="family">Nöth</namePart>
                        <namePart type="given">Eric</namePart>
                        <role>
                            <roleTerm type="code" authority="marcrelator">aut</roleTerm>
                        </role>
                    </name>
                    <typeOfResource>text</typeOfResource>
                    <genre authority="dini">doctoralThesis</genre>
                    <originInfo>
                        <dateIssued encoding="w3cdtf" keyDate="yes">2016</dateIssued>
                    </originInfo>
                    <language>
                        <languageTerm type="code" authority="iso639-2b">eng</languageTerm>
                    </language>
                    <abstract type="content" lang="eng">Lossless data compression is a classic research area of computer science. We use data compression not only to reduce the amount of space needed for big data structures, but also to accelerate algorithms or to find patterns in data. Oftentimes it is important that algorithms may operate directly on the compressed data (i.e.~without prior decompression). This is possible by using so-called grammar-based methods.

In this thesis we focus on the analysis of different grammar-based methods of tree compression.

In the first part of the thesis we prove that the average size of the DAG (directed acyclic graph) of a full binary tree with n inner nodes is asymptotically equal to (cn)/(sqrt(log n)) (where c is a constant). The DAG of a tree can be understood as a particular tree grammar, a so-called regular tree grammar. This result has only been sketched prior in the literature. We then generalize the proof to unranked trees and to a labelled setting. Then we compare the worst-case size of the DAG of a tree with the worst-case size of the so-called BDAG (for Binary DAG) of that tree. For this we introduce the HDAG (for Hybrid DAG), which is also interesting as a compression algorithm on its own. Then we discuss the use of grammar-based string compression for the construction of tree grammars. In the first method we compress certain sequences that arise during DAG compression and in the second method we use grammar-based string compression on the so-called traversal of a tree, which is the sequence of the tree’s node labels when the tree is traversed in depth-first/left-to-right manner. We call these kind of grammars traversal SLP (SLP stands for straight-line program, which are context-free grammars that generate precisely one word) and show that there exist trees such that the smallest traversal grammars for those trees are exponentially smaller than a smallest so-called tree straight-line program, which is a common grammar-based tree compression scheme. Next we discuss algorithms for compressed trees. 
Finally we show a case in which tree compression can accelerate computations. We show by experiments that automatic termination proving of term rewriting systems is faster if tree compression on the involved terms is used as an intermediate step.</abstract>
                    <abstract type="content" lang="ger">Verlustfreie Datenkompression ist ein wichtiges Forschungsgebiet der Informatik. Datenkompression wird nicht nur eingesetzt, um den Speicherbedarf großer Strukturen zu verringern, sondern auch, um Algorithmen zu beschleunigen oder um Muster in den Daten zu suchen. Häufig ist es wichtig, dass Algorithmen direkt auf der komprimierten Version der Datei operieren können (also keine Dekompression durchgeführt werden muss). Dies wird beispielsweise von sogenannten grammatik-basierten Verfahren gewährleistet.

In der vorliegenden Arbeit wurde der Fokus auf die Analyse verschiedener grammatik-basierter Verfahren der Baumkompression gelegt.

Zuerst wird bewiesen, dass die durchschnittliche Größe des DAGs (Englisch für directed acyclic graph, also gerichteter azyklischer Graph) eines vollen Binärbaums mit n inneren Knoten asymptotisch sich wie c n/(sqrt(log n)) verhält (wobei c eine Konstante ist). Dabei kann der DAG eines Baums als eine spezielle Baumgrammatik aufgefasst werden, eine sogenannte reguläre Baumgrammatik. Dieses Resultat wurde vorher in der Literatur nur skizziert. Das Ergebnis wird u.a. auf Bäume mit beliebigen Knotenrang verallgemeinert. Des Weiteren wird die Worst-Case Größe des DAGs eines Baums verglichen mit der Worst-Case Größe des eng verwandten BDAGs des Baums (für Binärer DAG). Für dieses Resultat wird der HDAG (für Hybrider DAG) eingeführt, welcher auch als eigenständiges Kompressionsverfahren interessant ist. Danach wird untersucht, inwiefern grammatik-basierte Stringkompression beim Erstellen von Baumgrammatik eingesetzt werden kann. Zunächst werden gewisse Sequenzen, die beim Erstellen des DAGs eines Baums entstehen, komprimiert, und anschließend wird Stringkompression verwendet, um die Sequenz zu komprimieren, die sich ergibt, wenn die Namen der einzelnen Knoten beim Traversieren des Baums ausgeschrieben werden (wobei jeder Name als Element eines Alphabets aufgefasst wird). Grammatiken dieser Art nennen wir Traversal SLP (SLP steht für straight-line program; dies sind kontextfreie Grammatiken, die genau Wort erzeugen). Es wird gezeigt, dass Traversal SLPs exponentiell bessere Ergebnisse gegenüber Baumkompression via sogenannten Tree Straight Line Programs (TSLP) erzielen können, einem weit verbreiteten Baumkompressionsparadigma. Außerdem werden noch einige Algorithmen für komprimierte Bäume vorgestellt. 
Schließlich diskutieren wir einen Fall, in welchem Baumkompression die Rechengeschwindigkeit beschleunigen kann. Wir zeigen durch Experimente, dass für automatisierte Terminationsbeweise von Termersetzungssystemen eine Kompression der Terme die durchschnittliche Rechenzeit verringert.</abstract>
                    <subject>
                        <topic>Azyklischer gerichteter Graph</topic>
                        <topic>Datenbäume</topic>
                        <topic>Data Compression</topic>
                        <topic>Trees</topic>
                    </subject>
                    <classification authority="ioo" displayLabel="Institut für Theoretische Informatik"></classification>
                    <identifier type="urn">urn:nbn:de:hbz:467-10193</identifier>
                    <identifier type="sys">HT019043528</identifier>
                    <recordInfo>
                        <recordIdentifier>siegen_opus_1019</recordIdentifier>
                    </recordInfo>
                    <extension>
                        <vl:doctype>oaDoctoralThesis</vl:doctype>
                        <vl:defenseDate>2016-06-08</vl:defenseDate>
                    </extension>
                </mods>
            </mets:xmlData>
        </mets:mdWrap>
    </mets:dmdSec>
    <mets:fileSec>
        <mets:fileGrp USE="pdf upload">
            <mets:file MIMETYPE="application/pdf" ID="FILE0_siegen_opus_1019">
                <mets:FLocat xlink:href="https://dspace.ub.uni-siegen.de/bitstream/ubsi/1019/1/Dissertation_Eric_John_Leo_Noeth.pdf" LOCTYPE="URL"/>
            </mets:file>
        </mets:fileGrp>
    </mets:fileSec>
    <mets:structMap TYPE="LOGICAL">
        <mets:div TYPE="document" ID="siegen_opus_1019"
            DMDID="DMD_siegen_opus_1019">
            <mets:fptr FILEID="FILE0_siegen_opus_1019"/>
        </mets:div>
    </mets:structMap>
</mets:mets>
